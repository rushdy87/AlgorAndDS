Jest
  - Jest is a delightful JavaScript Testing Framework with a focus on simplicity.
  - It works with projects using: Babel, TypeScript, Node, React, Angular, Vue and more!
________________________________________________________________________________________________________
Wherever passibole, I really recommended you avoid writing for loops in the kind of very classic syntax:
    for(var i= 0; i<str.length; i++) {} //this is classic syntax
because you may make a typo..
________________________________________________________________________________________________________
The split() method splits a string into an array of substrings.
________________________________________________________________________________________________________
The join() method returns an array as a string. The join() method does not change the original array.
Any separator can be specified.
________________________________________________________________________________________________________
reduce() method in JavaScript is used to reduce the array to a single value and executes a provided
function for each value of the array (from left-to-right) and the return value of the function is
stored in an accumulator.
________________________________________________________________________________________________________
The every() method tests whether all elements in the array pass the test implemented by the provided 
function. It returns a Boolean value.
________________________________________________________________________________________________________
The toString() method returns a string representing the object.
________________________________________________________________________________________________________
The parseInt() function parses a string argument and returns an integer of the specified radix.
parseInt(string)
parseInt(string, radix)
________________________________________________________________________________________________________
The Math.sign() function returns either a positive or negative +/- 1, indicating the sign of a number 
passed into the argument. If the number passed into Math.sign() is 0, it will return a +/- 0.
Note that if the number is positive, an explicit (+) will not be returned.
________________________________________________________________________________________________________
What is the difference between ( for... in ) and ( for... of ) statements?
  - for in loops over enumerable property names of an object.
  - for of (new in ES6) does use an object-specific iterator and loops over the values generated by that.
________________________________________________________________________________________________________
The slice() method returns a shallow copy of a portion of an array into a new array object selected from 
start to end (end not included) where start and end represent the index of items in that array. The 
original array will not be modified.

const animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];

console.log(animals.slice(2));
// expected output: Array ["camel", "duck", "elephant"]

console.log(animals.slice(2, 4));
// expected output: Array ["camel", "duck"]

console.log(animals.slice(1, 5));
// expected output: Array ["bison", "camel", "duck", "elephant"]

console.log(animals.slice(-2));
// expected output: Array ["duck", "elephant"]

console.log(animals.slice(2, -1));
// expected output: Array ["camel", "duck"]

console.log(animals.slice());
// expected output: Array ["ant", "bison", "camel", "duck", "elephant"]
________________________________________________________________________________________________________
The Array.from() static method creates a new, shallow-copied Array instance from an iterable 
or array-like object.

console.log(Array.from([1, 2, 3], x => x + x));
// expected output: Array [2, 4, 6]
________________________________________________________________________________________________________
RegExp
  - The RegExp object is used for matching text with a pattern.
  - There are two ways to create a RegExp object: a literal notation and a constructor.
    * The literal notation takes a pattern between two slashes, followed by optional flags, after the second slash.
    * The constructor function takes either a string or a RegExp object as its first parameter and a string of 
    optional flags as its second parameter.
  The following three expressions create the same regular expression object:
    const re = /ab+c/i; // literal notation
    // OR
    const re = new RegExp('ab+c', 'i'); // constructor with string pattern as first argument
    // OR
    const re = new RegExp(/ab+c/, 'i'); // constructor with regular expression literal as first argument
________________________________________________________________________________________________________
The Object.keys() method returns an array of a given object's own enumerable property names, 
iterated in the same order that a normal loop would.
________________________________________________________________________________________________________
The Array() constructor is used to create Array objects.
    new Array(element0, element1, /* â€¦ ,*/ elementN)
    new Array(arrayLength)
Arrays can be created using a constructor with a single number parameter. An array with its length property 
set to that number and the array elements are empty slots.
________________________________________________________________________________________________________
The fill() method changes all elements in an array to a static value, from a start index (default 0) to 
an end index (default array.length). It returns the modified array.
    const arr = new Array(5).fill('#') // equivalent to arr=['#','#','#','#','#']
________________________________________________________________________________________________________
Recursion:
  - Recursion is when a function calls itself until someone stops it.
  - It can be used instead of a loop.
  - If no one stops it, it'll recurse forever and crash your program.
  - A base case is a condition that stops the recursion. Don't forget to add them!
  - Loops use extra state variables for tracking and counting, while recursion only uses the provided parameters.
________________________________________________________________________________________________________
The repeat() method constructs and returns a new string which contains the specified number of copies of 
the string on which it was called, concatenated together.
'#'.repeat(3) // ==> '###'
________________________________________________________________________________________________________
The includes() method determines whether an array (or a string) includes a certain value among its entries, 
returning true or false as appropriate.
[1, 2, 3].includes(2) // return true;
'abcdef'.includes('g') // return false;
________________________________________________________________________________________________________
The match() method retrieves the result of matching a string against a regular expression.
match(regexp).
________________________________________________________________________________________________________
Runtime Complexity
  - Describes the performance of an algorithm
  - How much more processing power/time is required to run your algorithm if we double the inputs?
________________________________________________________________________________________________________
Big 'O' Notation
  - Big O notation describes the complexity of your code using algebraic terms.
  - What is efficiency of your algorithm?
________________________________________________________________________________________________________
Common Runtime Complexity:
1- Constant Time:
  - No matter how many elements we're working with, the algorithm/operation/whatever will always take the same amount of time.
  - Represented by O(1).
  const sum = (a, b) => a+b;

2- Logarithmic Time:
  - You have this if doubling the number of elements you are iterating over doesn't double the amount of work.
    Always assume that searching operations are log(n).
  - Represented by O(log(n)).
  while (x>0) {
    x = x/2;
  }

3- Linear Runtime:
  - Iterating through all elements in a collection of data.  If you see a for loop spanning from '0' to 'array.length', 
    you probably have 'n', or linear runtime.
  - Represented by O(n).
  for (i=0; i<n; i++) {
    sum += arr[i];
  }
  
4- Quasilinear Runtime (or, Linearithmic Runtime):
  - You have this if doubling the number of elements you are iterating over doesn't double the amount of work. Always assume 
    that any sorting operation is n*log(n).
  - Represented as O(n*log(n)).

5- Quadratic Runtime:
  - Every element in a collection has to be compared to every other element. 'The handshake problem'.
  - Expressed as O(n^2).
  for (i=0; i<row; i++) {
    for (j=1; j<col; j++) {
      console.log (arr[i][j]);
    }
  }

6- Exponential Runtime:
  - If you add a *single* element to a collection, the processing power required doubles.
  - Represented as O(2^n).
________________________________________________________________________________________________________
Tips around identifying Runtime Complexity:
- Iterating with a simple for loop through a single collection?
  Probably O(n).
- Iterating through half a collection?
  Still O(n).  There are no constants in runtime.
- Iterating through two *different* collections with separate for loops?
  O(n + m).
- Two nested for loops iterating over the same collection?
  O(n^2).
- Two nested for loops iterating over different collections?
  O(n*m).
- Sorting?
  O(n*log(n)).
- Searching a sorted array?
  O(log(n))
________________________________________________________________________________________________________
Space Complexity:
  - Space Complexity is a thing too.
  - How much more memory is required by doubling the problem set?
________________________________________________________________________________________________________
Memoization:
  - Store the arguments of each function call along with the result. If the function is called again with 
  the same arguments, return the precomputed result, rather than running the function again.
  - memoization is an optimization technique.
  - see this article: https://www.freecodecamp.org/news/memoization-in-javascript-and-react/
________________________________________________________________________________________________________
